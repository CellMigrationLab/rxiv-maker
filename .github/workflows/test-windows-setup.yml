name: Test Windows Setup

on:
  workflow_dispatch:
    inputs:
      debug_enabled:
        description: 'Enable debug mode'
        required: false
        default: false
        type: boolean
      manuscript_path:
        description: 'Path to manuscript directory'
        required: false
        default: 'EXAMPLE_MANUSCRIPT'
        type: string

jobs:
  test-windows-setup:
    runs-on: windows-latest
    env:
      MANUSCRIPT_PATH: ${{ github.event.inputs.manuscript_path || 'EXAMPLE_MANUSCRIPT' }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set manuscript path
      run: |
        $manuscriptPath = "${{ github.event.inputs.manuscript_path }}"
        if ([string]::IsNullOrEmpty($manuscriptPath)) {
          $manuscriptPath = "EXAMPLE_MANUSCRIPT"
        }
        Write-Host "Using manuscript path: $manuscriptPath"
        echo "MANUSCRIPT_PATH=$manuscriptPath" >> $env:GITHUB_ENV
      shell: pwsh

    # Cache Chocolatey packages to speed up installations
    - name: Cache Chocolatey packages
      uses: actions/cache@v4
      with:
        path: |
          C:\ProgramData\chocolatey\lib
          C:\ProgramData\chocolatey\cache
        key: ${{ runner.os }}-chocolatey-${{ hashFiles('.github/workflows/test-windows-setup.yml') }}
        restore-keys: |
          ${{ runner.os }}-chocolatey-

    # Cache Node.js global modules
    - name: Cache Node.js global modules
      uses: actions/cache@v4
      with:
        path: |
          ~\AppData\Roaming\npm
          ~\AppData\Roaming\npm-cache
        key: ${{ runner.os }}-npm-global-${{ hashFiles('.github/workflows/test-windows-setup.yml') }}
        restore-keys: |
          ${{ runner.os }}-npm-global-

    # Cache uv installation
    - name: Cache uv installation
      uses: actions/cache@v4
      with:
        path: |
          ~\.local\bin
          ~\.cargo\bin
        key: ${{ runner.os }}-uv-${{ hashFiles('.github/workflows/test-windows-setup.yml') }}
        restore-keys: |
          ${{ runner.os }}-uv-

    # Cache TinyTeX download
    - name: Cache TinyTeX download
      uses: actions/cache@v4
      with:
        path: |
          C:\TinyTeX
          ${{ runner.temp }}\TinyTeX.zip
        key: ${{ runner.os }}-tinytex-2024.01
        restore-keys: |
          ${{ runner.os }}-tinytex-

    # Install tools sequentially (background jobs don't work in GitHub Actions)
    - name: Install Make
      run: |
        Write-Host "Installing Make..."
        choco install make --no-progress
        Write-Host "✅ Make installation completed"
      shell: pwsh

    - name: Install Node.js and Mermaid CLI  
      run: |
        Write-Host "Installing Node.js..."
        choco install nodejs --no-progress
        Write-Host "✅ Node.js installation completed"
        
        Write-Host "Installing Mermaid CLI..."
        npm install -g @mermaid-js/mermaid-cli
        Write-Host "✅ Mermaid CLI installation completed"
      shell: pwsh

    - name: Install uv package manager
      run: |
        Write-Host "Installing uv..."
        powershell -Command "irm https://astral.sh/uv/install.ps1 | iex"
        $uvPath = "$env:USERPROFILE\.local\bin"
        echo "$uvPath" >> $env:GITHUB_PATH
        Write-Host "✅ uv installation completed at: $uvPath"
      shell: pwsh

    - name: Install LaTeX with multiple fallback strategies
      run: |
        Write-Host "=== Installing LaTeX with Fallback Strategies ==="
        $latexInstalled = $false
        
        # Check if TinyTeX is already cached and working
        $tinyTexBin = "C:\TinyTeX\TinyTeX\bin\windows"
        if (Test-Path "$tinyTexBin\pdflatex.exe") {
          Write-Host "✅ TinyTeX found in cache and verified"
          $env:PATH = "$tinyTexBin;$env:PATH"
          echo "$tinyTexBin" >> $env:GITHUB_PATH
          $latexInstalled = $true
        }
        
        # Strategy 1: TinyTeX (more reliable for CI) - Try this if not cached
        if (-not $latexInstalled) {
          try {
            Write-Host "Attempting TinyTeX installation (primary method)..."
            $tinyTexUrl = "https://github.com/rstudio/tinytex-releases/releases/download/v2024.01/TinyTeX-2-v2024.01.zip"
            $tinyTexZip = "$env:TEMP\TinyTeX.zip"
            $tinyTexDir = "C:\TinyTeX"
            
            # Check if ZIP is already cached
            if (Test-Path $tinyTexZip) {
              Write-Host "TinyTeX ZIP found in cache, skipping download"
            } else {
              Write-Host "Downloading TinyTeX (approximately 200MB)..."
              # Use shorter timeout and retry logic
              $retryCount = 0
              $maxRetries = 3
              $downloadSuccess = $false
              
              while (-not $downloadSuccess -and $retryCount -lt $maxRetries) {
                try {
                  Invoke-WebRequest -Uri $tinyTexUrl -OutFile $tinyTexZip -UseBasicParsing -TimeoutSec 300
                  $downloadSuccess = $true
                  Write-Host "Download completed successfully"
                } catch {
                  $retryCount++
                  Write-Host "Download attempt $retryCount failed: $_"
                  if ($retryCount -lt $maxRetries) {
                    Write-Host "Retrying in 10 seconds..."
                    Start-Sleep 10
                  }
                }
              }
              
              if (-not $downloadSuccess) {
                throw "Failed to download TinyTeX after $maxRetries attempts"
              }
            }
            
            Write-Host "Extracting TinyTeX..."
            Expand-Archive -Path $tinyTexZip -DestinationPath $tinyTexDir -Force
            
            # Add to PATH
            $env:PATH = "$tinyTexBin;$env:PATH"
            echo "$tinyTexBin" >> $env:GITHUB_PATH
            
            # Verify installation
            if (Test-Path "$tinyTexBin\pdflatex.exe") {
              Write-Host "✅ TinyTeX installation completed and verified"
              $latexInstalled = $true
            } else {
              Write-Host "⚠️ TinyTeX extraction may have failed - pdflatex not found"
            }
          } catch {
            Write-Host "⚠️ TinyTeX installation failed: $_"
          }
        }
        
        # Strategy 2: MiKTeX with very short timeout (only if TinyTeX fails)
        if (-not $latexInstalled) {
          try {
            Write-Host "Attempting MiKTeX installation (short timeout)..."
            $env:CHOCO_TIMEOUT = "300"  # 5 minutes max
            choco install miktex --no-progress --timeout=300 --ignore-http-cache
            Write-Host "✅ MiKTeX installation completed"
            $latexInstalled = $true
          } catch {
            Write-Host "⚠️ MiKTeX installation failed: $_"
          }
        }
        
        # Strategy 3: Minimal LaTeX via winget (last resort)
        if (-not $latexInstalled) {
          try {
            Write-Host "Attempting minimal LaTeX via winget..."
            winget install --id MiKTeX.MiKTeX --silent --accept-package-agreements --accept-source-agreements --disable-interactivity
            
            # Check common installation paths
            $miktexPaths = @(
              "$env:ProgramFiles\MiKTeX\miktex\bin\x64",
              "$env:LOCALAPPDATA\Programs\MiKTeX\miktex\bin\x64"
            )
            
            foreach ($path in $miktexPaths) {
              if (Test-Path "$path\pdflatex.exe") {
                $env:PATH = "$path;$env:PATH"
                echo "$path" >> $env:GITHUB_PATH
                Write-Host "✅ Winget LaTeX installation completed at: $path"
                $latexInstalled = $true
                break
              }
            }
            
            if (-not $latexInstalled) {
              Write-Host "⚠️ Winget installation completed but pdflatex not found"
            }
          } catch {
            Write-Host "⚠️ Winget installation failed: $_"
          }
        }
        
        if (-not $latexInstalled) {
          Write-Host "⚠️ All LaTeX installation methods failed - workflow will continue without LaTeX"
          Write-Host "This means PDF generation tests will be skipped"
        }
        
        echo "LATEX_INSTALLED=$latexInstalled" >> $env:GITHUB_ENV
      shell: pwsh

    # Force Unix shell detection for Makefile in GitHub Actions
    - name: Setup Makefile environment for GitHub Actions
      run: |
        Write-Host "Setting up Makefile environment variables for GitHub Actions..."
        # GitHub Actions uses bash even on Windows, so force Unix-style detection
        echo "MAKEFILE_FORCE_UNIX=1" >> $env:GITHUB_ENV
        echo "SHELL=/bin/bash" >> $env:GITHUB_ENV
        Write-Host "✅ Makefile environment configured for GitHub Actions"
      shell: pwsh

    - name: Verify all tools installation
      run: |
        Write-Host "=== Verifying All Tools Installation ==="
        
        # Test Make
        try {
          make --version
          Write-Host "✅ Make is available"
        } catch {
          Write-Host "⚠️ Make not found"
        }
        
        # Test Node.js and Mermaid
        try {
          node --version
          Write-Host "✅ Node.js is available"
          mmdc --version
          Write-Host "✅ Mermaid CLI is available"
        } catch {
          Write-Host "⚠️ Node.js or Mermaid CLI not found"
        }
        
        # Test uv
        try {
          uv --version
          Write-Host "✅ uv is available"
        } catch {
          Write-Host "⚠️ uv not found"
        }
        
        # Test LaTeX
        $latexFound = $false
        $latexCommands = @("pdflatex", "latex")
        foreach ($cmd in $latexCommands) {
          try {
            $result = & $cmd --version 2>&1
            if ($LASTEXITCODE -eq 0) {
              Write-Host "✅ $cmd is available"
              $latexFound = $true
              break
            }
          } catch {
            Write-Host "⚠️ $cmd not found"
          }
        }
        
        if (-not $latexFound -and $env:LATEX_INSTALLED -eq "True") {
          Write-Host "⚠️ LaTeX reported as installed but commands not accessible"
        }
        
        Write-Host "=== Tool Verification Complete ==="
      shell: pwsh

    - name: Test Python environment setup
      run: |
        Write-Host "Testing Python environment setup..."
        try {
          make setup
          Write-Host "✅ Python environment setup completed"
        } catch {
          Write-Host "⚠️ Python environment setup failed: $_"
        }
      shell: pwsh

    - name: Debug - Show platform info
      if: ${{ github.event.inputs.debug_enabled == 'true' }}
      run: |
        Write-Host "=== Platform Information ==="
        Write-Host "Platform: Windows"
        Write-Host "OS: windows-latest"
        Write-Host "Working directory: $(Get-Location)"
        Write-Host "Manuscript path: $env:MANUSCRIPT_PATH"
        Write-Host "=== Directory Contents ==="
        Get-ChildItem -Force | Format-Table -AutoSize
        Write-Host "=== PATH Environment ==="
        $env:PATH -split ';' | ForEach-Object { Write-Host $_ }
      shell: pwsh

    - name: Install uv (Windows)
      run: |
        Write-Host "Installing uv package manager..."
        powershell -Command "irm https://astral.sh/uv/install.ps1 | iex"
        $uvPath = "$env:USERPROFILE\.cargo\bin"
        Write-Host "Adding uv to PATH: $uvPath"
        echo "$uvPath" >> $env:GITHUB_PATH
      shell: pwsh

    - name: Verify uv installation
      run: |
        Write-Host "Verifying uv installation..."
        $uvPath = "$env:USERPROFILE\.cargo\bin\uv.exe"
        if (Test-Path $uvPath) {
          Write-Host "✅ uv found at: $uvPath"
          & $uvPath --version
        } else {
          Write-Host "❌ uv not found, checking PATH..."
          Get-Command uv -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "Found uv at: $($_.Source)" }
          try {
            & uv --version
            Write-Host "✅ uv command successful"
          } catch {
            Write-Host "❌ uv command failed: $_"
          }
        }
      shell: pwsh

    # Cache virtual environment and dependencies
    - name: Cache virtual environment
      uses: actions/cache@v4
      with:
        path: .venv
        key: ${{ runner.os }}-venv-${{ hashFiles('pyproject.toml', 'requirements*.txt') }}
        restore-keys: |
          ${{ runner.os }}-venv-

    - name: Test make setup
      run: |
        Write-Host "Running make setup..."
        $env:UV_SYSTEM_PYTHON = "1"
        make setup
        Write-Host "✅ Make setup completed successfully"
      shell: pwsh

    - name: Verify virtual environment creation
      run: |
        Write-Host "Verifying virtual environment creation..."
        $venvPython = ".venv\Scripts\python.exe"
        if (Test-Path $venvPython) {
          Write-Host "✅ Virtual environment created successfully on Windows"
          Write-Host "Python version in venv:"
          & $venvPython --version
          Write-Host "Installed packages:"
          & $venvPython -m pip list
        } else {
          Write-Host "❌ Virtual environment not found on Windows"
          Write-Host "Contents of .venv directory:"
          if (Test-Path ".venv") {
            Get-ChildItem -Path ".venv" -Recurse | Format-Table -AutoSize
          } else {
            Write-Host "❌ .venv directory does not exist"
          }
          exit 1
        }
      shell: pwsh

    # Cache LaTeX outputs
    - name: Cache LaTeX outputs
      uses: actions/cache@v4
      with:
        path: |
          output/*.aux
          output/*.bbl
          output/*.blg
          output/*.toc
          output/*.out
        key: ${{ runner.os }}-latex-${{ hashFiles('${{ env.MANUSCRIPT_PATH }}/**/*.md', '${{ env.MANUSCRIPT_PATH }}/**/*.bib', '${{ env.MANUSCRIPT_PATH }}/**/*.yml') }}
        restore-keys: |
          ${{ runner.os }}-latex-

    # Cache processed figures
    - name: Cache processed figures
      uses: actions/cache@v4
      with:
        path: |
          ${{ env.MANUSCRIPT_PATH }}/FIGURES/*/
          cache/figures
        key: ${{ runner.os }}-figures-${{ hashFiles('${{ env.MANUSCRIPT_PATH }}/FIGURES/**/*') }}
        restore-keys: |
          ${{ runner.os }}-figures-

    - name: Test make pdf with clean build
      run: |
        Write-Host "Running clean build process..."
        Write-Host "Cleaning previous outputs..."
        make clean
        
        Write-Host "Creating necessary directories..."
        if (!(Test-Path "output")) {
          New-Item -ItemType Directory -Path "output" -Force
        }
        
        Write-Host "Generating PDF for: $env:MANUSCRIPT_PATH"
        $env:FORCE_FIGURES = "true"
        make pdf MANUSCRIPT_PATH=$env:MANUSCRIPT_PATH
        Write-Host "✅ PDF generation completed"
      shell: pwsh

    - name: Verify PDF generation
      run: |
        Write-Host "Verifying PDF generation..."
        $pdfPath = "output\$env:MANUSCRIPT_PATH.pdf"
        Write-Host "Looking for PDF at: $pdfPath"
        
        if (Test-Path $pdfPath) {
          Write-Host "✅ PDF generated successfully: $pdfPath"
          $pdfInfo = Get-Item $pdfPath
          Write-Host "File size: $($pdfInfo.Length) bytes"
          Write-Host "Created: $($pdfInfo.CreationTime)"
          Write-Host "Modified: $($pdfInfo.LastWriteTime)"
        } else {
          Write-Host "❌ ERROR: PDF not found at $pdfPath"
          Write-Host "Contents of output directory:"
          if (Test-Path "output") {
            Get-ChildItem -Path "output" -Recurse | Format-Table -AutoSize
          } else {
            Write-Host "❌ Output directory not found"
          }
          
          Write-Host "Checking for LaTeX log files:"
          Get-ChildItem -Path "output" -Filter "*.log" -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "=== $($_.Name) ==="
            Get-Content $_.FullName -Tail 50
          }
          exit 1
        }
      shell: pwsh

    - name: Check output directory structure
      run: |
        Write-Host "=== Output Directory Structure ==="
        if (Test-Path "output") {
          Get-ChildItem -Path "output" -Recurse | Format-Table -AutoSize
        } else {
          Write-Host "❌ Output directory not found"
        }
        
        Write-Host "=== Generated Files Summary ==="
        Get-ChildItem -Path "output" -Include "*.pdf", "*.tex", "*.log" -Recurse -ErrorAction SilentlyContinue | 
          ForEach-Object {
            Write-Host "$($_.Extension.ToUpper()) file: $($_.Name) ($($_.Length) bytes)"
          }
      shell: pwsh

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: windows-output-${{ github.run_number }}
        path: |
          output/
          .venv/
        retention-days: 7

    - name: Test cleanup
      if: always()
      run: |
        Write-Host "Running cleanup..."
        make clean
        Write-Host "✅ Cleanup completed"
      shell: pwsh

    - name: Final status report
      if: always()
      run: |
        Write-Host "=== Windows Setup Test Summary ==="
        Write-Host "Manuscript: $env:MANUSCRIPT_PATH"
        Write-Host "Workflow: ${{ github.workflow }}"
        Write-Host "Run ID: ${{ github.run_id }}"
        Write-Host "Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')"
        
        $pdfPath = "output\$env:MANUSCRIPT_PATH.pdf"
        if (Test-Path $pdfPath) {
          Write-Host "Status: ✅ SUCCESS - PDF generated successfully"
        } else {
          Write-Host "Status: ❌ FAILURE - PDF not generated"
        }
        Write-Host "================================="
      shell: pwsh