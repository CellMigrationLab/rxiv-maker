# RXiv-Maker: An Automated Template Engine for Streamlined Scientific Publications
<!-- note that this title is not rendered in the PDF, rather the one in the YAML metadata is used -->

## Abstract
Modern scientific publishing has moved towards rapid dissemination through preprint servers, putting greater demands on researchers for preparing and quality-checking manuscripts. We introduce RXiv-Maker, a focused, lightweight system native to GitHub that streamlines scientific writing through markdown-based authoring with automated LaTeX conversion. Designed to bridge the gap between accessible writing tools and professional typesetting, the system prioritises reproducibility through native GitHub Actions integration rather than attempting to serve multiple output formats or user profiles. RXiv-Maker offers a deliberate, opinionated workflow that integrates version control and automation practices into scientific writing, including cloud-based GitHub Actions with native LaTeX installation, interactive Google Colab notebooks, and reproducible local builds via virtual environments. The framework ensures reproducibility by providing automated build environments with controlled dependency management and version-controlled workflows. This self-documenting article, created entirely within the framework, demonstrates how this approach offers an efficient, collaborative, and transparent workflow for producing reproducible preprints, empowering researchers to focus on content while maintaining rigorous standards of scientific integrity.

## Main

<!-- Introduction -->

![](FIGURES/Figure_1.svg)
{#fig:diagram tex_position="t"} **The RXiv-Maker Diagram.** The system integrates Markdown content, YAML metadata, Python scripts, and bibliography files through a processing engine. This engine leverages GitHub Actions, virtual environments, and LaTeX to produce a publication-ready scientific article, demonstrating a fully automated and reproducible pipeline.

Today's scientific landscape is marked by the swift sharing of research findings, a trend largely driven by the exponential growth of preprint servers like arXiv, bioRxiv, and medRxiv [@Berg2016;@Abdill2019_biorxiv_growth;@Fraser2021_preprint_growth]. The remarkable scale of this growth is illustrated in @sfig:arxiv-growth. This shift, while accelerating scientific discovery and enhancing research transparency [@Vale2019_preprints;@Tennant2016_academic_publishing], has transferred the burden of quality control, typesetting, and reproducibility assurance directly onto authors. Traditional workflows, often reliant on proprietary binary formats, hinder effective version control with systems like Git, while manual synchronisation of contributions is both error-prone and inefficient [@Lariviere2014;@da_Silva_2022_challenges]. To address these challenges, we have developed RXiv-Maker, a GitHub-native framework that embraces a focused, developer-centric approach to scientific manuscript preparation. Rather than attempting to serve diverse output formats or complex multi-format workflows, RXiv-Maker is deliberately designed to excel at a single, critical task: producing high-quality PDF preprints efficiently and reproducibly. This focused approach allows researchers to leverage familiar markdown syntax while benefiting from professional LaTeX typesetting, without requiring extensive technical expertise. The framework is built on the principle of computational reproducibility, providing automated guardrails that would typically be the domain of journal production staff. By leveraging GitHub Actions with native LaTeX environments and controlled dependency management, RXiv-Maker ensures that manuscripts can be rebuilt consistently across different systems and time periods, addressing the fundamental challenge of computational preservation in scientific publishing.

![](FIGURES/Figure_2.svg)
{#fig:workflow width="\textwidth" tex_position="t"} **RXiv-Maker Workflow: User Input vs. Automated Processing.** The framework clearly separates user responsibilities (content creation and configuration) from automated processes (parsing, conversion, compilation, and output generation). Users only need to write content and set preferences, while the system handles all technical aspects of manuscript preparation automatically, ensuring a streamlined workflow from markdown input to publication-ready PDF output.

RXiv-Maker prioritizes reproducibility throughout the publication process [@Donoho2010;@Sandve2013_reproducible_research;@Wilson2014_software_carpentry]. The framework enables programmatic generation of figures and tables, following computational research best practices [@Scherer2020_reproducibility]. Instead of using static image files, which disconnect data from visualization, the system uses scripting languages like Python with visualization libraries such as Matplotlib [@Hunter2007_matplotlib] and Seaborn [@Waskom2021_seaborn]. Figures are generated directly from source data and analysis scripts during compilation, creating a direct link from raw data to final figure. When underlying data is updated or analysis is refined, affected figures are automatically regenerated, ensuring consistency and preventing outdated visuals. The system also integrates Mermaid.js [@Mermaid2023_documentation] for generating diagrams and flowcharts from text-based syntax, useful for illustrating experimental workflows, conceptual models, and algorithms. The complete range of supported figure generation methods is detailed in @stable:figure-formats. This approach treats the manuscript as an executable output of the research process rather than a static document. Built upon the established HenriquesLab bioRxiv template [@HenriquesLab2015_template], RXiv-Maker extends capabilities through automated processing pipelines and flexible deployment strategies. The architecture, detailed in @fig:diagram and comprehensively illustrated in @fig:workflow, provides robust build automation through GitHub Actions and virtual environments. The technical details of the figure generation system are described in @snote:figure-generation.

To understand RXiv-Maker's distinct features, it is important to position it within the broader ecosystem of scientific authoring tools. The current landscape can be broadly categorised into distinct paradigms, each reflecting different philosophical approaches to document creation. All-in-one publishing systems like Quarto are designed for maximum versatility, integrating features for multi-language, multi-format output from a single source. Real-time collaborative editors such as Overleaf democratise LaTeX authoring through web-based interfaces with low technical barriers. Computational narrative frameworks like MyST and Jupyter Book treat documents as executable entities, prioritising web-first, interactive outputs. Modern typesetting engines like Typst represent a fundamental rethinking of the typesetting process with cleaner syntax and faster compilation. RXiv-Maker occupies a specific niche within this ecosystem: developer-centric automation optimised for reproducible PDF preprint generation, with workflow reproducibility as its core strength. A detailed comparison of these approaches is provided in @stable:tool-comparison, with extended analysis in @snote:comparison.

<!-- Results -->

Using the RXiv-Maker framework results in a highly efficient and robust workflow for producing professional-quality scientific papers. The system's primary output is a fully typeset PDF document, as seen in the article you're currently reading, which was generated entirely using this process. The markdown source files are automatically converted into a structured LaTeX document, then compiled to produce a PDF with a clean, academic layout, proper pagination, and high-resolution figures. Bibliographic management is handled seamlessly through integration with a standard BibTeX file. The system automatically processes this file to generate correctly formatted in-text citations and a comprehensive bibliography section according to a specified citation style. This automation eliminates the tedious and error-prone task of manually formatting references.

The system's deployment strategy addresses a fundamental challenge in computational reproducibility: ensuring that research outputs can be reliably reconstructed across different environments and time periods. The cloud-based GitHub Actions workflow represents a paradigm shift from local, environment-dependent builds to standardised, auditable compilation processes. Every repository push triggers an automated workflow that provisions a fresh, controlled environment with specific versions of LaTeX, Python, and system dependencies. This approach eliminates the variability introduced by different local installations and provides a permanent, citable record of the exact computational environment used for each manuscript version. The resulting PDF artifacts are automatically archived and made available for download, creating an unbroken chain of computational provenance from source files to final output. For users requiring immediate feedback, the system also supports deployment in Google Colab notebooks, providing an interactive environment that maintains the same reproducibility guarantees while offering real-time compilation capabilities. A comprehensive comparison of available deployment strategies is provided in @stable:deployment-options.

The integration of programmatic figure generation was also validated, supporting interactive computational environments like Jupyter notebooks [@Jupyter2016_notebook]. Python scripts placed within the designated directory were automatically executed during compilation. These scripts loaded data, performed analyses, and generated visualisations, which were then saved as image files and seamlessly included in the final PDF. Similarly, Mermaid.js diagrams embedded within the markdown source were correctly rendered into SVG images and incorporated into the document. This programmatic integration demonstrates a closed loop of reproducibility, where the final manuscript serves as a verifiable and self-contained record of the research findings and their presentation.

<!-- Discussion and conclusions section -->

By integrating plain-text authoring with automated build environments, RXiv-Maker provides a robust solution to the challenges of ensuring consistency and reproducibility in manuscript preparation. The framework's focused approach—optimising for a single, critical task rather than attempting broad functionality—enables deeper integration with version control systems and automation practices that are essential for modern research workflows. This specialisation allows the system to excel at what matters most for scientific preprints: reliability, reproducibility, and seamless integration with collaborative research practices. The approach embraces literate programming principles [@Knuth1984_literate_programming], creating documents that seamlessly blend narrative text with executable code. Rather than forcing researchers to become amateur typesetters, the system handles typesetting complexity while preserving the transparent, version-controlled workflow that modern research demands. The integration with Git provides transparent attribution, conflict-free merging of contributions, and a complete, auditable history of manuscript development [@Ram2013_git_science;@Perez-Riverol2016_github_bioinformatics].

The rise of preprints has fundamentally shifted the burden of quality control, typesetting, and reproducibility assurance from journal production staff directly onto authors. RXiv-Maker responds to this cultural shift by providing the automated guardrails that researchers now need to produce publication-quality work from the very first public dissemination of their findings. By focusing on automated figure generation and standardised build processes, the framework makes it straightforward to create publications that are not just reports of research, but are themselves computationally reproducible artefacts. This directly addresses the 'reproducibility crisis' by embedding best practices into the authoring workflow itself [@Donoho2010]. The framework's GitHub-native design leverages the infrastructure that has become the de facto standard for collaborative software development and is increasingly adopted for scientific projects, positioning researchers to benefit from the maturity and reliability of modern development practices. Additional details on the reproducibility features and version control integration are provided in @snote:reproducibility.

The deliberate focus on PDF output via LaTeX represents a conscious design choice to optimise the preprint workflow rather than a limitation. While this specialisation means the system does not currently support HTML or other web-native formats, this focused approach enables deeper optimisation for the specific requirements of scientific preprint preparation. Future development could extend format support through integration with universal document converters like Pandoc [@MacFarlane2022], though this would require careful consideration of how to maintain the current level of typographic control and reproducibility guarantees. The learning curve associated with Git and markdown workflows reflects the investment required to leverage modern version control practices, which yield significant dividends in reproducibility and collaboration capabilities. Concerns about reporting quality in preprints [@Kirkham2018_reporting] suggest opportunities for integrating automated quality checks and validation workflows. Future development will focus on deeper integration with data analysis environments like Jupyter notebooks and exploration of automated tools for style, grammar, and scientific rigour assessment, further enhancing the system's role as a comprehensive manuscript preparation platform. Advanced template customisation and styling options are detailed in @snote:customisation.

## Methods

The following section provides a detailed technical description of the RXiv-Maker framework, serving as both the methods for this paper and as a practical demonstration of the system's capacity for generating complex, structured documentation from source code and plain text. A comprehensive overview of the system architecture is provided in @sfig:architecture.

### The RXiv-Maker Processing Pipeline: A Deterministic Automated Workflow

The RXiv-Maker framework implements a deterministic, multi-stage processing pipeline to convert manuscript source files into a compiled Portable Document Format (PDF) document. The entire workflow is orchestrated by a central Makefile that defines a directed acyclic graph (DAG) of dependencies, ensuring a consistent and reproducible order of operations for every build. This Makefile serves as the high-level algorithmic specification for the tool, defining distinct pathways for local compilation and cloud-based GitHub Actions workflows.

The primary build process, typically invoked via the `make pdf` target for local compilation, proceeds through five distinct, logically ordered stages:

**Environment Setup** (`setup`): The initial stage prepares the build environment by creating the designated output directory (`output/`) and its necessary subdirectories (e.g., `output/Figures/`). This ensures a clean and predictable workspace for all subsequent build artifacts.

**Programmatic Content Generation** (`figures-conditional`): This stage manages the creation of dynamic content, primarily figures. A key methodological feature is its conditional execution logic. The system inspects the `FIGURES/` directory for source files (e.g., `.py` for Python scripts, `.mmd` for Mermaid diagrams) and checks for the existence of corresponding output files (e.g., `.pdf`, `.png`). The figure generation script (`src/py/commands/generate_figures.py`) is executed only if these output files are absent or if the user explicitly forces regeneration by setting the `FORCE_FIGURES=true` flag. This caching-like behavior represents a critical optimization, balancing the need for reproducibility with computational efficiency by avoiding redundant processing of unchanged assets.

**Core Content Conversion** (`generate`): This is the central conversion step, where the main Python script (`src/py/commands/generate_preprint.py`) is executed. This script parses the primary manuscript markdown file (`MANUSCRIPT/01_MAIN.md`), extracts metadata from the configuration file (`MANUSCRIPT/00_CONFIG.yml`), and synthesizes these inputs into a master LaTeX file (`MANUSCRIPT.tex`) within the output directory.

**Asset Aggregation** (`copy-files`): Following the generation of the primary LaTeX file, this stage gathers all necessary dependencies for compilation into the `output/` directory. This includes LaTeX style files (`.cls`, `.bst`, `.sty`) from `src/tex/style/`, the project's bibliography file (`.bib`), and all generated figures from the `FIGURES/` directory. This aggregation creates a self-contained environment for the final typesetting stage.

**Final Typesetting** (`pdf`): The final stage executes the LaTeX compilation sequence within the `output/` directory. A standard, robust sequence of `pdflatex → bibtex → pdflatex → pdflatex` is used. This multi-pass process ensures that all cross-references (for figures, tables, and equations) and bibliographic citations are correctly resolved, resulting in a polished, publication-ready PDF document. The framework's mathematical typesetting capabilities are detailed in @snote:mathematical-formulas, with enhanced equation support described in @snote:numbered-equations. A timeout wrapper is applied to each command to prevent build processes from hanging indefinitely.

For users without a local LaTeX installation, the framework provides cloud-based compilation via GitHub Actions, which automatically sets up the complete LaTeX environment and executes the build pipeline upon code changes. This approach ensures consistent builds across different systems and provides reproducible outputs without requiring users to manage complex local dependencies.

The Makefile defines several key automation targets that orchestrate the build process: `setup` creates the output directory structure, `figures-conditional` manages programmatic figure generation, `generate` performs the core markdown-to-LaTeX conversion, `copy-files` aggregates all necessary assets, `build` ensures readiness for typesetting, and `pdf` executes the LaTeX compilation sequence. The architectural philosophy and project organisation principles are detailed in @snote:file-structure.

### The Markdown-to-LaTeX Conversion Engine

The transformation of the user's markdown manuscript into a structured LaTeX document is not performed by a generic, off-the-shelf converter. Instead, RXiv-Maker employs a custom, multi-pass conversion engine written in Python (`src/py/converters/md2tex.py`). This engine is designed to recognize and process a specific "extended academic Markdown" syntax, which adds essential scientific publishing features to the standard markdown specification. The precise behavior of this engine is formally documented and validated by a comprehensive suite of unit tests, particularly those found in `tests/unit/test_md2tex.py`.

The conversion process can be understood as a pipeline of specialized processing functions, each responsible for a specific syntactic element. This modular architecture allows for robust and maintainable code, where complex transformations are broken down into discrete, testable steps. The key stages of this conversion pipeline include:

**Code Block Protection**: The first pass identifies all fenced code blocks (e.g., ` ```python... ``` `) and replaces them with unique, protected placeholders. This crucial step ensures that the content within these blocks is treated as literal text and is not subjected to any subsequent markdown-to-LaTeX conversion. This preserves code syntax, YAML examples, and other verbatim content without corruption.

**Specialized Element Conversion**: The engine then applies a series of dedicated converters to the remaining text:
- *Citation Processing* (`convert_citations_to_latex`): This function identifies two citation patterns. Single, in-text citations like `@smith2023` are converted to `\cite{smith2023}`. Bracketed, multi-citation groups like `[@smith2023;@jones2022]` are converted to the consolidated LaTeX command `\cite{smith2023,jones2022}`.
- *Figure Processing* (`convert_figures_to_latex`): This processor handles the complex syntax for embedding figures. It recognizes attributes for labels (`#fig:id`), width (`width="0.8"`), and LaTeX placement (`tex_position="!ht"`), translating them into the appropriate `\begin{figure}`, `\includegraphics`, and `\label` commands.
- *Table Processing* (`convert_tables_to_latex`): This handles GitHub-flavored markdown tables, converting them into LaTeX tabular environments. It also supports extended attributes for rotation (`rotate=90`) and column width, wrapping the table in `\rotatebox` or `tabularx` environments as needed.
- *Supplementary Note Processing* (`process_supplementary_notes`): A custom syntax, `{#snote:id} **Title.**`, is used for creating structured supplementary notes. This processor converts these blocks into formatted LaTeX subsections with automatic numbering and labeling, a feature essential for organizing supplementary information.

**Standard Markdown Conversion**: After the specialized elements are handled, the engine applies standard markdown conversion rules for basic formatting, such as transforming `**bold**` to `\textbf{bold}`, `*italic*` to `\textit{italic}`, and headers (`#`, `##`) to LaTeX sectioning commands (`\section`, `\subsection`).

**Placeholder Restoration**: Finally, the protected placeholders for code blocks are restored, inserting the original verbatim content into the appropriate LaTeX environment for syntax highlighting.

This multi-pass, protection-first approach ensures that the extended academic syntax is processed correctly while preventing the accidental conversion of literal content within code blocks. The conversion engine supports several custom syntax extensions including bracketed citations, figure placement attributes, cross-references, rotated tables, language-specific code blocks, and structured supplementary notes. A comprehensive overview of the supported markdown syntax is provided in @stable:markdown-syntax, with detailed technical implementation described in @snote:markdown-conversion.

### Programmatic Content Generation for Reproducible Science

A cornerstone of the RXiv-Maker methodology is its direct support for programmatic content generation, which transforms figures and diagrams from static, manually-created assets into dynamic, reproducible outputs of the scientific analysis itself. This capability is not an add-on but a core, algorithmically-defined part of the build pipeline, ensuring that the final publication is a verifiable and auditable record of the research process.

The mechanism is orchestrated by the `figures` and `figures-conditional` targets in the Makefile. The process follows a clear algorithm:

**Source Identification**: During a build, the system scans the `MANUSCRIPT/FIGURES/` directory for files with recognized executable extensions, primarily `.py` for Python scripts and `.mmd` for Mermaid diagram definitions.

**Conditional Execution**: As described previously, the `figures-conditional` logic determines whether a script needs to be executed. This check for pre-existing output files serves as an effective caching mechanism, significantly speeding up subsequent builds where figure-generating code or data has not changed.

**Interpreter Dispatch**: If execution is required, the system dispatches the source file to the appropriate interpreter:
- *Python Scripts* (`.py`): Files ending in `.py` are executed using the project's configured Python interpreter (`$(PYTHON_CMD)`). These scripts are expected to perform data loading, analysis, and plotting (e.g., using libraries like Matplotlib and Seaborn, as specified in `pyproject.toml`), and save the resulting visualizations as image files (e.g., `.pdf`, `.png`) back into the `FIGURES/` directory.
- *Mermaid Diagrams* (`.mmd`): Files ending in `.mmd` are processed using the Mermaid CLI. This converts the declarative, text-based diagram syntax into vector (`.svg`, `.pdf`) and raster (`.png`) graphics. This allows complex flowcharts and architectural diagrams to be version-controlled and automatically rendered as part of the manuscript.

**Integration**: Once the output files are generated, the markdown-to-LaTeX conversion engine recognizes the corresponding `![Caption](...)` tags in the manuscript's markdown source and embeds the newly created figures into the final document.

This entire process ensures a tight coupling between the data, the code that analyzes it, and the final visual representation in the publication. It elevates the manuscript from a static report to a dynamic, executable artifact, which is a significant step towards achieving the ideals of fully reproducible computational science.

### Environment Management for Consistent Builds

Reproducibility in computational science is critically dependent on the stability of the software environment. To address this, RXiv-Maker provides a multi-layered strategy for environment management, ensuring that the tool behaves consistently across different systems. This is a deliberate methodological choice to eliminate the common "works on my machine" problem.

**Dependency Pinning**: At the most fundamental level, the `pyproject.toml` file explicitly lists all Python dependencies with version specifiers (e.g., `matplotlib>=3.7.0`, `ruff>=0.8.0`). This provides a baseline level of reproducibility for any installation, as it instructs the package manager to use versions known to be compatible with the tool.

**Virtual Environments**: For local development, the Makefile provides a `venv` target to create an isolated Python virtual environment. This prevents conflicts with system-wide packages and ensures that the project's dependencies are self-contained.

**GitHub Actions Integration**: The highest level of consistency is achieved through GitHub Actions workflows that automatically provision complete build environments. These workflows install specific versions of Python, LaTeX distributions, and system dependencies, ensuring that builds are performed in controlled, reproducible environments regardless of the user's local setup. This approach eliminates environment-related variability and provides consistent outputs across different execution contexts.

### The Quality Assurance and Validation Framework

In computational science, the software testing framework serves the same role as experimental controls and validation assays in empirical science. It provides the evidence that the computational instrument—the software—is behaving as specified. RXiv-Maker employs a formal, multi-level testing strategy to validate its functionality, which should be described as the validation protocol for the method.

The testing framework, managed via Makefile targets and configured in `pyproject.toml`, is structured into three distinct layers:

**Unit Tests** (`tests/unit/`): This suite forms the foundation of the validation strategy. Each test validates a single, discrete component or conversion rule in isolation. These tests function as precise positive and negative controls. For example, `test_convert_bold_text` in `test_md2tex.py` validates that the `**text**` to `\textbf{text}` conversion works correctly (a positive control). Conversely, tests for markdown inside backticks validate that this same conversion does not occur inside a code block, confirming the specificity of the rule (a negative control). This suite provides granular, verifiable evidence that the core algorithms of the conversion engine are implemented correctly.

**Integration Tests** (`tests/integration/`): This layer validates the successful orchestration of multiple components. Tests like `test_end_to_end_with_citations` verify that the entire pipeline—from parsing a markdown file containing citations and figure references, to generating a LaTeX file with the correct `\cite` and `\ref` commands—functions as a cohesive whole. These tests are analogous to validating a complete experimental protocol from sample preparation to final measurement, ensuring that the interfaces between different modules are working correctly.

**Platform Tests** (`tests/integration/test_platform_integration.py`): This layer validates the tool's functionality in its target deployment environments. These tests verify the behavior of the GitHub Actions workflows, ensuring that cloud-based builds produce the expected results across different platforms and execution contexts.

In addition to this validation suite, the project enforces a proactive quality control pipeline using pre-commit hooks, configured in `.pre-commit-config.yaml`. Before any code change can be committed to the version control system, a series of automated checks are executed. These include code formatting (`ruff-format`), linting (`ruff`), type checking (`mypy`), and even spell-checking of configuration files (`typos`). This automated pipeline serves as a continuous, preventative quality assurance method, ensuring a high standard of code quality, consistency, and correctness throughout the development process.

The project's tooling choices also reflect a deliberate methodology aimed at quality and performance. The configuration explicitly adopts modern, high-performance tools. For instance, the traditional Python-based tools `black`, `isort`, and `flake8` have been replaced by the single, Rust-based tool Ruff, reflecting a move towards faster alternatives while maintaining established tools like `mypy` for type checking. This hybrid approach demonstrates a sophisticated, evidence-based methodology for toolchain construction, prioritizing performance and developer efficiency while maintaining best-in-class functionality.

## Data availability
Arxiv monthly submission data used in this article is available at [https://arxiv.org/stats/monthly_submissions](https://arxiv.org/stats/monthly_submissions). The source code and data for the figures in this article are available at [https://github.com/henriques/rxiv-maker](https://github.com/henriques/rxiv-maker).

## Code availability
The RXiv-Maker computational framework is available at [https://github.com/henriques/rxiv-maker](https://github.com/henriques/rxiv-maker). All source code is under an MIT License.

## Author contributions
Both Bruno M. Saraiva, Guillaume Jacquemet and Ricardo Henriques conceived the project and designed the framework. All authors contributed to writing and reviewing the manuscript.

## Acknowledgements
B.S. and R.H. acknowledge support from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement No. 101001332) (to R.H.) and funding from the European Union through the Horizon Europe program (AI4LIFE project with grant agreement 101057970-AI4LIFE and RT-SuperES project with grant agreement 101099654-RTSuperES to R.H.). Funded by the European Union. However, the views and opinions expressed are those of the authors only and do not necessarily reflect those of the European Union. Neither the European Union nor the granting authority can be held responsible for them. This work was also supported by a European Molecular Biology Organization (EMBO) installation grant (EMBO-2020-IG-4734 to R.H.), a Chan Zuckerberg Initiative Visual Proteomics Grant (vpi-0000000044 with https://doi.org/10.37921/743590vtudfp to R.H.) and a Chan Zuckerberg Initiative Essential Open Source Software for Science (EOSS6-0000000260). This study was supported by the Academy of Finland (no. 338537 to G.J.), the Sigrid Juselius Foundation (to G.J.), the Cancer Society of Finland (Syöpäjärjestöt, to G.J.) and the Solutions for Health strategic funding to Åbo Akademi University (to G.J.). This research was supported by InFLAMES Flagship Program of the Academy of Finland (decision no. 337531).
